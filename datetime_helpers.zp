(define datetime:MINYEAR 1)
(define datetime:MAXYEAR 9999)
(define datetime:_MAXORDINAL 3652059)
(define datetime:_DAYS_IN_MONTH [-1 31 28 31 30 31 30 31 31 30 31 30 31])
(define datetime:_DAYS_BEFORE_MONTH
      (map 
        (lambda (x) 
          (let ((el (+ 1 (math:list-sum (list:ref datetime:_DAYS_IN_MONTH 0 x)))))
            (if (= 1 el) -1 el)))
        (range 0 13)))

(define datetime:_MONTHNAMES ["" "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"])
(define datetime:_DAYNAMES ["" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun"])

(define (datetime:_is_leap year) "checks whether year is a leap year"
    (and (= 0 (mod year 4)) (or (/= 0 (mod year 100)) (= 0 (mod year 400)))))

(define (datetime:_days_before_year year) "returns number of days before first day of year"
    (let ((y (- year 1)))
      (- (+ (* y 365) (/ y 4) (/ y 400)) (/ y 100))))

(define (datetime:_days_in_month year month) "returns number of days in month in year"
    (if (and (= month 2) (datetime:_is_leap year))
      29
      (list:ref datetime:_DAYS_IN_MONTH month)))

(define (datetime:_days_before_month year month) "number of days in year preceding first day of month"
    (if (and (> month 2) (datetime:_is_leap year))
      (+ (list:ref datetime:_DAYS_BEFORE_MONTH month) 1)
      (list:ref datetime:_DAYS_BEFORE_MONTH month)))

(define (datetime:_ymd2ord year month day) "ordinal, considering 01-Jan-0001 as day 1"
    (let ((dim (datetime:_days_in_month year month)))
      (+ (datetime:_days_before_year year)
         (datetime:_days_before_month year month)
         day)))

(define datetime:_DI400Y (datetime:_days_before_year 401))
(define datetime:_DI100Y (datetime:_days_before_year 101))
(define datetime:_DI4Y (datetime:_days_before_year 5))

(define (datetime:_ord2ymd n) "'(year month day), considering 01-Jan-0001 as day 1."
  (let* ((n (- n 1))
         (tmp (divmod n datetime:_DI400Y))
         (n400 (car tmp))
         (n (cadr tmp))
         (year (+ (* n400 400) 1))
         (tmp (divmod n datetime:_DI100Y))
         (n100 (car tmp))
         (n (cadr tmp))
         (tmp (divmod n datetime:_DI4Y))
         (n4 (car tmp))
         (n (cadr tmp))
         (tmp (divmod n 365))
         (n1 (car tmp))
         (n (cadr tmp))
         (year (+ year (* n100 100) (* n4 4) n1)))
         (if (or (= n1 4) (= n100 4))
          (list (- year 1) 12 31)
          (let* ((month (>> (+ n 50) 5))
                 (prec (+ (list:ref datetime:_DAYS_BEFORE_MONTH month)
                          (if (and (> month 2) (datetime:_is_leap year)) 1 0))))
            (if (> prec n)
              (let* ((month (- month 1))
                     (prec (- prec (+ (list:ref datetime:_DAYS_IN_MONTH month)
                                      (if (and (> month 2) (datetime:_is_leap year)) 1 0)))))
                (list year month (+ (- n prec) 1)))
              (list year month (+ (- n prec) 1)))))))

(define (datetime:_weekday-string ordinal)
  (list:ref datetime:_DAYNAMES (+ (mod (+ ordinal 6) 7) 1)))

(define (datetime:_format-time ord y m d hh mm ss tmz tzdelta us)
  (let* ((trail (lambda (x) (if (> 2 (length x)) (++ "0" x) x)))
         (tzdstr (if (/= 0 tzdelta) (++ " (" (number->string tzdelta) ")") ""))
         (fillns (lambda (x) 
            (define (fill str l)
              (if (> l 0)
                (fill (++ "0" str) (- l 1))
                str))
             (fill x (- 6 (length x)))))
         (result (++ (datetime:_weekday-string ord) " " (number->string d) " "
                     (list:ref datetime:_MONTHNAMES m) " " (number->string y)
                     " " (trail (number->string hh)) ":" (trail (number->string mm)) ":"
                     (trail (number->string ss)))))
    (if (falsy? us)
        (++ result " " tmz tzdstr)
        (++ result "." (fillns (number->string us)) " " tmz tzdstr))))

(define (datetime:_to-unix y m d hh mm ss tzdelta)
  (let ((yy (reduce
              (lambda (acc x)
                (if (datetime:_is_leap x) (+ 366 acc) (+ 365 acc)))
              0
              (range 1970 y))))
    (+ (* yy 24 60 60)
       (* (list:ref datetime:_DAYS_BEFORE_MONTH m) 24 60 60)
       (* (- d 1) 24 60 60)
       (+ (* hh 60 60) tzdelta)
       (* mm 60)
       ss)))

(define (datetime:_from-unix ts)
  (let* ((y (/ ts (* 365 24 60 60)))
         (ld (- (reduce (lambda (acc n)
                          (if (datetime:_is_leap n) (+ acc 1) acc))
                        0
                        (range 1970 (+ y 1971)))
                1))
         (d (- (/ ts (* 24 60 60)) (* y 365) ld))
         (get-m-until (lambda (n)
          (reduce (lambda (acc x) (if (< x n) x acc)) 0 datetime:_DAYS_BEFORE_MONTH)))
         (m (list:index datetime:_DAYS_BEFORE_MONTH (get-m-until d)))
         (mdays (list:ref datetime:_DAYS_BEFORE_MONTH m))
         (d (- d mdays))
         (tmpy (* y 365 24))
         (tmpd (* (+ d ld mdays) 24))
         (hh (- (/ ts (* 60 60)) tmpd tmpy))
         (tmpy (* tmpy 60))
         (tmpd (* tmpd 60))
         (tmph (* hh 60))
         (mm (- (/ ts 60) tmph tmpd tmpy))
         (ss (- ts (* mm 60) (* tmph 60) (* tmpd 60) (* tmpy 60))))
       (list (+ y 1970) m d hh mm ss)))

(define datetime:_SECOND 1)
(define datetime:_MINUTE (* 60 datetime:_SECOND))
(define datetime:_HOUR (* 60 datetime:_MINUTE))
(define datetime:_DAY (* 24 datetime:_HOUR))
(define datetime:_YEAR (* 365 datetime:_DAY))

(define datetime:_DDAYS {"Sweetmorn" "Boomtime" "Pungenday" "Prickle-Prickle" "Setting Orange"})
(define datetime:_DSEASONS {"Chaos" "Discord" "Confusion" "Bureaucracy" "The Aftermath"})

(define datetime:_HOLYDAYS
  #{"Chaos" #{5  "Mungday"
              50 "Chaoflux"}
    "Discord" #{5  "Mojoday"
                50 "Discoflux"}
    "Confusion" #{5  "Syaday"
                  50 "Confuflux"}
    "Bureaucracy" #{5  "Zaraday"
                    50 "Bureflux"}
    "The Aftermath" #{5  "Maladay"
                      50 "Afflux"}})

(define (datetime:_hail-eris ts)
  (let* ((leps   (floor (/. ts datetime:_YEAR 4)))
         (ts     (- ts (* leps datetime:_DAY)))
         (cur    (floor (/. (mod ts datetime:_YEAR) datetime:_DAY)))
         (flarf  (floor (+ (/. ts datetime:_YEAR) 3136)))
         (ist    (= 0 (mod (- flarf 3130) 4)))
         (tabby  (and ist (> cur 59)))
         (cur    (if tabby (sub1 cur) cur))
         (gwar   (add1 (floor (mod cur 73))))
         (sn     (floor (/. cur 73)))
         (woody  (remainder cur 5))
         (numstr (lambda (d)
                  (++ (->string d)
                    (if (and (> (mod d 100) 11) (< (mod d 100) 21))
                      "th"
                      (case (mod d 10)
                        ((1) "st")
                        ((2) "nd")
                        ((3) "rd")
                        (else "th"))))))
         (holy   (get-from datetime:_HOLYDAYS (list (datetime:_DSEASONS sn) gwar) #f)))
    (++ (datetime:_DDAYS woody) ", " (datetime:_DSEASONS sn) " " (numstr gwar) ", " (->string flarf)  " YOLD"
        (if (truthy? holy) (++ "\nIt's " holy "!") ""))))
